1.1.1. Write a Program to Search an element using Linear Search and Recursion

#include<stdio.h>
void read1(int a[], int n) {
	printf("Enter %d elements : ",n);
	for (int i=0; i<n; i++) {
		scanf("%d", &a[i]);
	}
}

int linearSearch(int a[], int i, int n, int key){
	if(i > n)
		return -1;

	if(a[i] == key)
		return i;

	return linearSearch(a,i + 1, n, key);
}


1.1.2. Write a Program to Search an element using Binary Search and Recursion

# include <stdio.h>

void read1(int a[], int n){
	printf("Enter %d elements : ",n);
		for(int i =0; i<n ;i++){
			scanf("%d",&a[i]);
		}
}


void bubbleSort(int a[], int n){
	int temp;
	for(int i=0; i<n-1; i++){
		for(int j=0; j<n-i-1;j++){
			if(a[j]>a[j+1]){
				temp = a[j];
				a[j] = a[j + 1];
				a[j+1] = temp;
			}
		}
	}
}

void display ( int a[], int n){
	int i;
	for(i =0; i< n; i++){
		printf("%d ", a[i]);
	}
	printf("\n");
}


int binarySearch(int a[], int low, int high, int key){
	if(low> high){
		return -1;
	}
	int mid = (low+ high)/2;

	if(a[mid] == key){
		return mid;
	}
	if(key < a[mid]){
		return binarySearch(a, low, mid - 1, key);
	}
	else{
		return binarySearch(a, mid + 1, high, key);
	}
}


1.1.3. Quick sort

#include <stdio.h>

// Function to print a part of the array
void printArray(int arr[], int start, int end) {
    for (int i = start; i <= end; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Partition function for Quick Sort
int partition(int arr[], int low, int high, int* pass) {
    int pivot = arr[high];
    int i = low - 1, temp;

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            // Swap arr[i] and arr[j]
            temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    // Swap arr[i+1] and arr[high]
    temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;

    // Print current pass
    printf("Pass: ");
    printArray(arr, low, high);
    (*pass)++;

    return i + 1;
}

// Quick Sort function
void quickSort(int arr[], int low, int high, int* pass) {
    if (low < high) {
        int pi = partition(arr, low, high, pass);
        quickSort(arr, low, pi - 1, pass);
        quickSort(arr, pi + 1, high, pass);
    }
}
int main() {
    int n, i, pass = 1;

    printf("number of elements: ");
    scanf("%d", &n);

    int arr[n]; // VLA: valid in C99+

    printf("elements: ");
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    quickSort(arr, 0, n - 1, &pass);

    printf("Sorted array: ");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}


1.1.4. Merge Sort

// Type Content here...
#include <stdio.h>
#include <stdlib.h>

void print_subarray(int a[], int l, int r) {
for (int i = l; i <= r; i++) {
printf("%d ", a[i]);
if (i < r) 
printf("");
}
printf("\n");
}

void merge(int a[], int l, int m, int r, int temp[]) {
int i = l, j = m + 1, k = l;
while (i <= m && j <= r) {
if (a[i] <= a[j]) 
temp[k++] = a[i++];
else 
temp[k++] = a[j++];
}
while (i <= m) 
temp[k++] = a[i++];
while (j <= r) 
temp[k++] = a[j++];
for (i = l; i <= r; i++) 
a[i] = temp[i];
printf("Pass: ");
print_subarray(a, l, r);
}
void mergesort(int a[], int l, int r, int temp[]) {
if (l >= r) 
return;
int m = (l + r) / 2;
mergesort(a, l, m, temp);
mergesort(a, m + 1, r, temp);
merge(a, l, m, r, temp);
}

int main() {
int n;
printf("no of elements: ");
scanf("%d", &n);

int *a = (int *)malloc(n * sizeof(int));
int *temp = (int *)malloc(n * sizeof(int));

printf("elements: ");
for (int i = 0; i < n; i++) {
scanf("%d", &a[i]);
}

printf("Given array:\n");
for (int i = 0; i < n; i++) {
printf("%d", a[i]);
if (i < n - 1) 
printf(" ");
}
printf(" \n");

mergesort(a, 0, n - 1, temp);

printf("Sorted array:\n");
for (int i = 0; i < n; i++) {
printf("%d", a[i]);
if (i < n - 1) 
printf(" ");
}
printf(" \n");

free(a);
free(temp);
return 0;
}



1.1.5. Prims Algorithm

#include <stdio.h>
#include <stdbool.h>
#include <limits.h>
#define V 100

int minKey(int key[], bool mstSet[], int vertices) {
	// Write your code here...
int min = INT_MAX, min_index;
for (int v = 0; v < vertices; v++) {
if (!mstSet[v] && key[v] < min) {
min = key[v];
min_index = v;
}
}
return min_index;





}
void printTree(int parent[], int graph[V][V], int vertices) {
    printf("Edge \tWeight\n");
    for (int i = 1; i < vertices; i++)
        printf("%d - %d \t%d \n", parent[i], i, graph[i][parent[i]]);
}

void prim(int graph[V][V], int vertices) {
	// Write your code here...
	int parent[V];
int key[V];
bool mstSet[V];

for (int i = 0; i < vertices; i++) {
key[i] = INT_MAX;
mstSet[i] = false;
}

key[0] = 0;
parent[0] = -1;

for (int count = 0; count < vertices - 1; count++) {
int u = minKey(key, mstSet, vertices);
mstSet[u] = true;

for (int v = 0; v < vertices; v++) {
if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {
parent[v] = u;
key[v] = graph[u][v];
}
}
}
    printTree(parent, graph, vertices);


	
	
	
	
	
	
	
	
}

int main() {
    int vertices;
    int graph[V][V];

    printf("No of vertices: ");
    scanf("%d", &vertices);

    printf("Adjacency matrix elements (row wise):\n");
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    prim(graph, vertices);

    return 0;
}


1.1.6. kruskals Algorithm

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>


#define INF 9999

typedef struct {
    int src, dest, weight;
} Edge;

int find(int parent[], int i) {
    if (parent[i] != i)
        parent[i] = find(parent, parent[i]);
    return parent[i];
}

void union1(int parent[], int rank[], int x, int y) {
    int xroot = find(parent, x);
    int yroot = find(parent, y);
    
    if (rank[xroot] < rank[yroot])
        parent[xroot] = yroot;
    else if (rank[xroot] > rank[yroot])
        parent[yroot] = xroot;
    else {
        parent[yroot] = xroot;
        rank[xroot]++;
    }
}

int compareEdges(const void *a, const void *b) {
    Edge *e1 = (Edge *)a;
    Edge *e2 = (Edge *)b;
    if (e1->weight != e2->weight)
        return e1->weight - e2->weight;
    if (e1->src != e2->src)
        return e1->src - e2->src;
    return e1->dest - e2->dest;
}




void kruskalMST(int **cost, int V) {
    Edge *edges = (Edge *)malloc(V * V * sizeof(Edge));
    int edgeCount = 0;

    for (int i = 0; i < V; i++) {
        for (int j = i + 1; j < V; j++) {
            if (cost[i][j] != INF) {
                edges[edgeCount].src = i;
                edges[edgeCount].dest = j;
                edges[edgeCount].weight = cost[i][j];
                edgeCount++;
            }
        }
	}
    qsort(edges, edgeCount, sizeof(Edge), compareEdges);

    int *parent = (int *)malloc(V * sizeof(int));
    int *rank = (int *)malloc(V * sizeof(int));
    for (int i = 0; i < V; i++) {
        parent[i] = i;
        rank[i] = 0;
    }

    int e = 0, i = 0, minCost = 0;

    while (e < V - 1 && i < edgeCount) {
        Edge next_edge = edges[i++];
        int x = find(parent, next_edge.src);
        int y = find(parent, next_edge.dest);

        if (x != y) {
            printf("Edge %d:(%d, %d) cost:%d\n", e, next_edge.src, next_edge.dest, next_edge.weight);
            minCost += next_edge.weight;
            union1(parent, rank, x, y);
            e++;
		}
    }

    printf("Minimum cost= %d\n", minCost);
    free(edges);
    free(parent);
    free(rank);
}


int main() {
    int V;
    printf("No of vertices: ");
    scanf("%d", &V);

    int **cost = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
        cost[i] = (int *)malloc(V * sizeof(int));

    printf("Adjacency matrix:\n");
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++)
            scanf("%d", &cost[i][j]);

    kruskalMST(cost, V);

    for (int i = 0; i < V; i++)
        free(cost[i]);
    free(cost);

    return 0;
}


1.1.7. Dijkstra's Shortest Path Algorithm


#include <limits.h> 
#include <stdio.h>
#define MAX 20
int V, E;
int graph[MAX][MAX];
#define INFINITY 99999
void printPath(int parent[], int j) {
    int path[MAX];
    int pathIndex = 0;

    // Collect path from destination to source
    while (j != -1) {
        path[pathIndex++] = j;
        j = parent[j];
    }

    // Now print in reverse: destination <- ... <- source
    for (int i = 0; i < pathIndex; i++) {
        printf("%d", path[i]);
        if (i < pathIndex - 1) {
            printf("<-");
        }
    }
}
void dijkstra(int G[MAX][MAX], int n, int startnode) {
    int distance[MAX];
    int visited[MAX] = {0};
    int parent[MAX];

    for (int i = 1; i <= n; i++) {
        distance[i] = INFINITY;
        parent[i] = -1;
    }
    distance[startnode] = 0;

    for (int count = 1; count <= n - 1; count++) {
        int min = INFINITY, u = -1;
        for (int i = 1; i <= n; i++) {
            if (!visited[i] && distance[i] <= min) {
                min = distance[i];
                u = i;
            }
        }

        if (u == -1) break;

        visited[u] = 1;

        for (int v = 1; v <= n; v++) {
            if (!visited[v] && G[u][v] != 0 && distance[u] != INFINITY &&
                distance[u] + G[u][v] < distance[v]) {
                distance[v] = distance[u] + G[u][v];
                parent[v] = u;
            }
        }
	}
	printf("Node\tDistance\tPath\n");
	for (int i = 1; i <= n; i++) {
	    if (i == startnode) continue;
	
	    // Print node with 3 leading spaces and arrow
	    printf("   %d\t", i);
	
	    if (distance[i] == INFINITY) {
	        // 7 spaces after arrow
	        printf("     INF\tNO PATH\n");
	    } else {
	        // Print distance followed by 7 spaces, then arrow and path
	        printf("       %d\t", distance[i]);
	        printPath(parent, i);
	        printf("\n");
	    }
	}
}
int main() { 
	int s, d, w, i, j;
	printf("Enter the number of vertices : ");
	scanf("%d", &V);
	printf("Enter the number of edges : ");
	scanf("%d", &E);
	for(i = 1 ; i <= V; i++) {
		for(j = 1; j <= V; j++) {
			graph[i][i] = 0;
		}
	}
	for(i = 1; i <= E; i++) {
		printf("Enter source : ");
		scanf("%d", &s);
		printf("Enter destination : ");
		scanf("%d", &d);
		printf("Enter weight : ");
		scanf("%d", &w);
		if(s > V || d > V || s <= 0 || d <= 0) {
			printf("Invalid index. Try again.\n");
			i--;
			continue;
		} else {
			graph[s][d] = w;
		}
	}
	printf("Enter the source :");
	scanf("%d", &s);
	dijkstra(graph, V, s); 
	return 0; 
} 


1.1.8. Knapsack Problem

#include <stdio.h>

#define MAX 100

int max(int a, int b) {
	return (a > b) ? a : b;
}

int knapsack(int val[], int wt[], int N, int W) {
	int dp[MAX + 1][MAX + 1];

	for (int i = 0; i <= N; i++) {
		for (int w = 0; w <= W; w++) {
			if (i == 0 || w == 0)
				dp[i][w] = 0;
			else if (wt[i - 1] <= w)
				dp[i][w] = max(dp[i - 1][w], val[i - 1] + dp[i - 1][w - wt[i - 1]]);
			else
				dp[i][w] = dp[i - 1][w];
		}
	}

	return dp[N][W];
}

int main() {
	int N, W;
	int val[MAX], wt[MAX];

	scanf("%d", &N);
	for (int i = 0; i < N; i++)
		scanf("%d", &val[i]);
	for (int i = 0; i < N; i++)
		scanf("%d", &wt[i]);
	scanf("%d", &W);

	int result = knapsack(val, wt, N, W);
	printf("%d\n", result);

	return 0;
}








1.1.9. Fractional Knapsack Problem


# include<stdio.h>
void knapsack(int n, float weight[], float profit[], float capacity) {
	float total_profit = 0.0;
	int i;

	for (i = 0; i < n; i++) {
		if (capacity == 0) {
			break;
		}
		if (weight[i] <= capacity) {
			capacity -= weight[i];
			total_profit += profit[i];
		} else {
			total_profit += profit[i] * (capacity / weight[i]);
			capacity = 0;
		}
	}

	printf("Maximum profit is:- %.6f\n", total_profit);





1.1.10. Floyd - Warshall's Algorithm


#include <stdio.h>
#define INF 99999
#define MAX_N 20 // Maximum value for N
void floydWarshall(int graph[MAX_N][MAX_N], int n) {
	int dist[MAX_N][MAX_N], i, j, k;

	for (i = 0; i < n; i++) {
		for (j = 0; j < n; j++) {
			dist[i][j] = graph[i][j];
		}
	}

	for (k = 0; k < n; k++) {
		for (i = 0; i < n; i++) {
			for (j = 0; j < n; j++) {
				if (dist[i][k] != INF && dist[k][j] != INF && 
					dist[i][k] + dist[k][j] < dist[i][j]) {
					dist[i][j] = dist[i][k] + dist[k][j];
				}
			}
		}
	}

	printf("The following matrix shows the shortest distances between all pairs of the vertices.\n");
	for (i = 0; i < n; i++) {
		for (j = 0; j < n; j++) {
			if (dist[i][j] == INF)
				printf("  INF");
			else
				printf(  "  %3d", dist[i][j]);
		}
		printf("\n");
	}
}

int main() {
	int graph[MAX_N][MAX_N];
	int n, e, i, j;

	printf("Enter the number of vertices : ");
	scanf("%d", &n);

	printf("Enter the number of edges : ");
	scanf("%d", &e);

	for (i = 0; i < n; i++) {
		for (j = 0; j < n; j++) {
			if (i == j)
				graph[i][j] = 0;
			else
				graph[i][j] = INF;
		}
	}

	for (i = 0; i < e; i++) {
		int u, v, w;
		printf("Enter source : ");
		scanf("%d", &u);
		printf("Enter destination : ");
		scanf("%d", &v);
		printf("Enter weight : ");
		scanf("%d", &w);
		graph[u - 1][v - 1] = w;
	}

	floydWarshall(graph, n);

	return 0;
}





1.1.11. Optimal Merge Pattern



#include <stdio.h>
#include <stdlib.h>

// Function to Sort the files in ascending order, perform optimal file merging and return the minimum cost
int optimalMerge(int files[], int n) {
    int totalCost = 0;

	while(n > 1) {
		for(int i = 0; i < n - 1; i++) {
			for(int j = 0; j < n - i - 1; j++) {
				if(files[j] > files[j + 1]) {
					int tmp = files[j];
					files[j] = files[j + 1];
					files[j + 1] = tmp;
				}
			}
		}


		int mergedSize = files[0] + files[1];
		totalCost += mergedSize;

		files[0] = mergedSize;

		for(int i = 1; i < n - 1; i++) {
			files[i] = files[i + 1];
		 }
			 n--;
			 }
	return totalCost;
    
        
}

int main() {
    int n;
    printf("Number of files: ");
    scanf("%d", &n);
    int *files = (int *)malloc(n * sizeof(int));
    printf("Enter the sizes of %d files: ", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &files[i]);
    }
    int minCost = optimalMerge(files, n);
    printf("Minimum cost of merging is: %d\n", minCost);
    free(files);
    return 0;
}






1.1.12. N Queens Problem


#include <stdio.h>
#include <stdbool.h>

#define MAX 10

int solutionCount = 0;


bool isSafe(int board[MAX][MAX], int row, int col, int n) {
    int i, j;


    for (i = 0; i < row; i++)
        if (board[i][col])
            return false;


    for (i = row, j = col; i >= 0 && j >= 0; i--, j--)
        if (board[i][j])
            return false;


    for (i = row, j = col; i >= 0 && j < n; i--, j++)
        if (board[i][j])
            return false;

    return true;
}

void solveNQ(int board[MAX][MAX], int row, int n) {
    if (row == n) {
        solutionCount++;
        return;
	}

    for (int col = 0; col < n; col++) {
        if (isSafe(board, row, col, n)) {
            board[row][col] = 1;
            solveNQ(board, row + 1, n);
            board[row][col] = 0; // backtrack
        }
    }
}

int nQueen(int n) {
    int board[MAX][MAX] = {0};
    solutionCount = 0;
    solveNQ(board, 0, n);
    return solutionCount;
}

int main() {
    int n;
    scanf("%d", &n);
    printf("%d\n", nQueen(n));
    return 0;
}
